#lang racket

(require racket/flonum racket/unsafe/ops)
(require math/array)
(require
 ;; "synth.rkt"
 "mixer.rkt")


;; (provide scale chord note sequence mix-vector)
(provide (all-defined-out))

(define (base+relative-semitone->freq base relative-semitone)
  (* 440 (expt (expt 2 1/12) -57)))

;; details at http://www.phy.mtu.edu/~suits/notefreqs.html
(define (note-freq note)
  ;; A4 (440Hz) is 57 semitones above C0, which is our base.
  (* 440 (expt (expt 2 1/12) (- note 57))))

;; A note is represented using the number of semitones from C0.
(define (name+octave->note name octave)
  (+ (* 12 octave)
     (case name
       [(C) 0] [(C# Db) 1] [(D) 2] [(D# Eb) 3]  [(E) 4] [(F) 5] [(F# Gb) 6]
       [(G) 7] [(G# Ab) 8] [(A) 9] [(A# Bb) 10] [(B) 11])))

;; Generates a scale of the given mode (major, minor, ...) starting at
;; `root' at `octave'. `duration' is the duration of an individual note.
;; Custom scales can be generated by giving a list of semitone intervals.
;; Returns a list of note + duration pairs
;; TODO add option for descending
(define (scale root octave duration mode . notes*)
  (define root-note (name+octave->note root octave))
  (define notes
    (if (eq? mode 'custom)
        notes*
        (case mode
          ((major ionian)                '(0 2 4 5 7 9 11 12))
          ((minor minor-natural aeolian) '(0 2 3 5 7 8 10 12))
          ((minor-harmonic mohammedan)   '(0 2 3 5 7 8 11 12))
          ((minor-melodic)               '(0 2 3 5 7 9 11 12))
          ((dorian)                      '(0 2 3 5 7 9 10 12))
          ((phrygian)                    '(0 1 3 5 7 8 10 12))
          ((lydian)                      '(0 2 4 6 7 9 11 12))
          ((mixolydian)                  '(0 2 4 5 7 9 10 12))
          ((locrian)                     '(0 1 3 5 6 8 10 12))
          ((major-arpeggio)              '(0 4 7))
          ((minor-arpeggio)              '(0 3 7))
          ((custom)                      notes))))
  (for/list ([n (in-list notes)])
    (cons (+ root-note n) duration)))
;; TODO probably leave duration out of this (and chord) for now, and have it
;;  be part of a higher-level API

;; Similar to scale, but generates a chord.
;; Chords are pairs (listof note) + duration
(define (chord root octave duration type . notes*)
  (define notes (apply scale root octave duration type notes*))
  (cons (map car notes) duration))

;; Single note.
(define (note name octave duration)
  (printf "note: name ~a, octave ~a, note ~a\n" name octave (name+octave->note name octave))
  (cons (name+octave->note name octave) duration))

;; Accepts notes or pauses, but not chords.
(define (synthesize-note note n-samples function)
  ;; (define note-block (malloc _double n-samples 'atomic))

  ;; (printf "synthesize-note note: ~a, n-samples: ~a\n" note n-samples)
  (define synth (if note (function (note-freq note)) #f))
  ;; (for ([i (in-range n-samples)])
  ;;   (ptr-set! note-block i (if note ((third synth) i) 0.0)))
  ;; (print note-block)
  ;; (print "synth:") (pretty-display synth) (newline)

  (define ret
    (build-array (vector n-samples)
                 (if note
                     (compose (third synth) array-lambda-compose)
                     (lambda (x) 0.0))))
  (define retv (build-vector n-samples (if note (third synth) (lambda (x) 0.0))))
  (for ([a (in-array ret)]
        [v retv]
        [i (in-range n-samples)])
    (unless (equal? a v)
      (printf "not equal ~a\n" i)))
  ;; (pretty-display ret)
  retv) ; pause

;; repeats n times the sequence encoded by the pattern, at tempo bpm
;; pattern is a list of either single notes (note . duration) or
;; chords ((note ...) . duration) or pauses (#f . duration)
(define (sequence n pattern tempo function)
  (printf "sequence: pattern: ~a\n" pattern)
  (define samples-per-beat (quotient (* fs 60) tempo))
  (printf "sequencefs: ~a, samples-per-beat: ~a\n" fs samples-per-beat)
  (apply vector-append
         (for*/list ([i    (in-range n)] ; repeat the whole pattern
                     [note (in-list  pattern)])
           ;; (printf "sequence:for* i: ~a, note: ~a\n" i note)
           (if (list? (car note)) ; chord
               (apply mix
                      (for/list ([x (in-list (car note))])
                        (list (synthesize-note x
                                               (* samples-per-beat (cdr note))
                                               function)
                              1))) ; all of equal weight
               (synthesize-note (car note)
                                (* samples-per-beat (cdr note))
                                function)))))

;; (cons (vector float) real)* -> (vector float)
(define (mix-vector . ss)
  (printf "mix-vector: n: ~a, args: ~a" (length ss) ss)
  (define signals (map car ss))
  (define weights (map cdr ss))
  (define lengths (map vector-length signals))
  (define downscale-ratio (/ 1.0 (apply + weights)))
  ;; (define ((scale-signal s) x) (* x w downscale-signal))

  (define total-samples (apply max lengths))

  (define retv
    (build-vector
     total-samples
     (λ (i)
       (apply +
              (map (λ (ss)
                     (define s (car ss))
                     (define w (cdr ss))
                     (* w downscale-ratio
                        (vector-ref s (modulo i (vector-length s)))))
                   ss)))))
  retv)
